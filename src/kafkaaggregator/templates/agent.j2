"""Faust agent for the {{ aggregated_topic }} topic.

The agent (strem processor) persists the messages from the source stream
into a Faust table configured as a tumbling window.
See https://faust.readthedocs.io/en/latest/userguide/tables.html#windowing

If the source stream is produced at a constant rate, the number of messages
aggregated in each window is given by n = window_size * frequency.

Note that the window range is relative to the timestamp in the stream.

The window_expires parameter controls when the callback function that
processes the window is called. When a window is processed, a new
message is produced to the aggregated topic.
"""

__all__ = [
    "process_window",
    "process_source_topic",
]

import logging
from typing import Any, AsyncGenerator, List, Tuple

from faust import web
from faust.types import StreamT

from kafkaaggregator.aggregator import Aggregator
from kafkaaggregator.aggregator_config import AggregatorConfig
from kafkaaggregator.app import app

logger = logging.getLogger("kafkaaggregator")

aggregator_config = AggregatorConfig("{{ config_file }}").get("{{ aggregated_topic }}")

# Source stream
source_topic = app.topic(aggregator_config.source_topics[0])

aggregator = Aggregator(aggregator_config)

# The Faust Record for the aggregated topic is created at runtime
{{ cls_name }} = aggregator.async_create_record_and_register()

# Aggregated stream
aggregated_topic = app.topic(
    "{{ aggregated_topic }}",
    value_type={{ cls_name }},
    internal=True
)

def process_window(key: Tuple, value: List[Any]) -> None:
    """Process a window and send an aggregated message.

    Parameters
    ----------
    key: `Tuple`
        key for the current window in the WindowSet associated to
        ``Table[k]``. The key contains the window range.
        Example: ``key = (k, (start, end))``

    value: `list`
        List of messages in the current window.
    """
    start, end = key[1]

    # Faust defines the window range as (start,  start + size - 0.1)
    # https://github.com/robinhood/faust/blob/master/faust/types/windows.py#L16
    # To compute the midpoint of the window we have to correct the window range
    # by 0.1. Note that, despite of this definition, messages with timestamps
    # between (start + size - 0.1) and (start + size) are correctly added to
    # the current window.
    time = (start + end + 0.1) / 2

    aggregated_message = aggregator.compute(
        time=time,
        messages=value
    )

    aggregated_topic.send_soon(value=aggregated_message)

    logger.info(
        f"{aggregated_message.count:5d} messages aggregated on "
        f"{{ aggregated_topic }}-tumbling-window ({start:.2f}, "
        f"{(end + 0.1):.2f})."
    )


# Tumbling window to persist messages from the source stream, the process_window
# callback is called when the window expires. The window range is relative to
# the stream timestamp.

window_size_seconds = aggregator_config.window_aggregation.window_size_seconds
window_expiration_seconds = (
    aggregator_config.window_aggregation.window_expiration_seconds
)

table = (
    app.Table(
        "{{ aggregated_topic }}-tumbling-window",
        default=list,
        on_window_close=process_window,
        help=f"Persit messages in tumbling windows of {window_size_seconds}s.",
    )
    .tumbling(window_size_seconds, window_expiration_seconds)
    .relative_to_stream()
)


@app.agent(source_topic)
async def process_source_topic(stream: StreamT) -> AsyncGenerator:
    """Process incoming messages from the source topic."""
    async for message in stream:
        messages = table[source_topic].value()
        messages.append(message)
        table[source_topic] = messages

        yield message
